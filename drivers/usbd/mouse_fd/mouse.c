/*
 * usbd/mouse_fd/mouse.c
 *
 *      Copyright (c) 2003, 2004 Belcarra
 *
 * By: 
 *      Stuart Lynne <sl@belcarra.com>, 
 *      Tom Rushworth <tbr@belcarra.com>, 
 *      Bruce Balden <balden@belcarra.com>
 *
 * This is a test USB HID Function Driver designed to test and
 * verify that INTERRUPT IN endpoints work properly.
 *
 * This emulates a simple USB mouse and generates a constant stream
 * of small random mouse movements.
 *
 * To use simply load with something like:
 *
 *      insmod mouse_fd.o vendor_id=0xffff product_id=0xffff
 *
 * And attach to a Windows box. Windows should recognize as a mouse and
 * immediately start receiving a stream of data. 
 *
 * To terminate simply unplug.
 *
 * The mouse driver has several other characteristics to allow testing of
 * other features of the bus interface driver:
 *
 *      - ep0 ZLP handling
 *
 *      - ep0 delayed CONTROL READ
 *
 *
 * Notes
 *
 * 1. The mouse driver is product name is hard coded to a string that will
 *    generate a string descriptor that is 32 bytes long. This will test
 *    most UDC's ep0 ZLP handling as it is a multiple of the most common
 *    UDC endpoint zero size. (An option can be added later to allow for
 *    64 byte ep0 packetsize.)
 *
 * 2. The CONFIG_USBD_MOUSE_BH option can be enabled to delay the HID report 
 *    to being generated by a bottom half handler. This will verify that 
 *    the bus interface driver properly handles the case of a delayed
 *    CONTROL READ. I.e. when the usbd_recv_setup_irq() function returns
 *    zero for successful completion but there is no tx_urb containing the
 *    requested data. The bus interface driver must setup the conditions for
 *    ACK'ing the SETUP packet but then NAK the IN data for endpoint zero
 *    until the tx_urb is started later.
 */


#include <linux/config.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/version.h>

#include <usbd-export.h>
#include <usbd-build.h>

MODULE_AUTHOR ("sl@belcarra.com, tbr@belcarra.com");
MODULE_LICENSE("PROPRIETARY");
MODULE_DESCRIPTION ("Belcarra Random Walk MOUSE Function");

#include <linux/init.h>
#include <asm/uaccess.h>
#include <linux/ctype.h>
#include <linux/timer.h>
#include <linux/interrupt.h>
#include <asm/atomic.h>
#include <linux/random.h>
#include <linux/slab.h>

#include "usbd-chap9.h"
#include <usbd-mem.h>
#include <usbd.h>
#include <usbd-func.h>

USBD_MODULE_INFO ("mouse_fd 2.0-beta");

/* Module Parameters ************************************************************************* */

static u32 vendor_id;
static u32 product_id;

MODULE_PARM (vendor_id, "i");
MODULE_PARM (product_id, "i");

MODULE_PARM_DESC (vendor_id, "Device Vendor ID");
MODULE_PARM_DESC (product_id, "Device Product ID");

/*
 * ep0 testing.... ensure that this is exactly 16 bytes
 */
#undef CONFIG_USBD_MOUSE_PRODUCT_NAME
#define CONFIG_USBD_MOUSE_PRODUCT_NAME "Belcarra  Mouse"

/*
 * MOUSE Configuration
 *
 * Endpoint, Class, Interface, Configuration and Device descriptors/descriptions
 */

#define BULK_INT        0x00
#define ENDPOINTS       0x01

char MouseHIDReport[52] = {
    0x05, 0x01,                    // USAGE_PAGE (Generic Desktop)
    0x09, 0x02,                    // USAGE (Mouse)
    0xa1, 0x01,                    // COLLECTION (Application)
    0x09, 0x01,                    //   USAGE (Pointer)
    0xa1, 0x00,                    //   COLLECTION (Physical)
    0x05, 0x09,                    //     USAGE_PAGE (Button)
    0x19, 0x01,                    //     USAGE_MINIMUM (Button 1)
    0x29, 0x03,                    //     USAGE_MAXIMUM (Button 3)
    0x15, 0x00,                    //     LOGICAL_MINIMUM (0)
    0x25, 0x01,                    //     LOGICAL_MAXIMUM (1)
    0x95, 0x03,                    //     REPORT_COUNT (3)
    0x75, 0x01,                    //     REPORT_SIZE (1)
    0x81, 0x02,                    //     INPUT (Data,Var,Abs)
    0x95, 0x01,                    //     REPORT_COUNT (1)
    0x75, 0x05,                    //     REPORT_SIZE (5)
    0x81, 0x03,                    //     INPUT (Cnst,Var,Abs)
    0x05, 0x01,                    //     USAGE_PAGE (Generic Desktop)
    0x09, 0x30,                    //     USAGE (X)
    0x09, 0x31,                    //     USAGE (Y)
    0x09, 0x38,                    //     USAGE (WHEEL)
    0x15, 0x81,                    //     LOGICAL_MINIMUM (-127)
    0x25, 0x7f,                    //     LOGICAL_MAXIMUM (127)
    0x75, 0x08,                    //     REPORT_SIZE (8)
    0x95, 0x03,                    //     REPORT_COUNT (3)
    0x81, 0x06,                    //     INPUT (Data,Var,Rel)
    0xc0,                          //   END_COLLECTION
    0xc0                           // END_COLLECTION
};

struct usb_endpoint_descriptor mouse_data = {
        bLength: 0x07, 
        bDescriptorType: USB_DT_ENDPOINT, 
        bEndpointAddress: IN, 
        bmAttributes: INTERRUPT, 
        wMaxPacketSize: __constant_cpu_to_le16(0x10), 
        bInterval: 0x01, 
};

struct hid_descriptor mouse_hid = {
        bLength: 0x09, 
        bDescriptorType: 0x21, 
        bcdHID: __constant_cpu_to_le16(0x110), 
        bCountryCode: 0x00, 
        bNumDescriptors: 0x01, 
        bReportType: 0x22, 
        wItemLength: __constant_cpu_to_le16(0x34), 
};

static struct usb_endpoint_descriptor *mouse_default[] = { &mouse_data, };
u8 mouse_indexes[] = { BULK_INT, };
static struct usb_generic_class_descriptor *mouse_hid_descriptors[] = { (struct usb_generic_class_descriptor *)&mouse_hid, };

/* Data Interface Alternate description(s)
 */
static __u8 mouse_data_alternate_descriptor[sizeof(struct usb_interface_descriptor)] = {
        0x09, USB_DT_INTERFACE, 0x00, 0x00, // bInterfaceNumber, bAlternateSetting
        sizeof (mouse_default) / sizeof(struct usb_endpoint_descriptor), // bNumEndpoints
        0x03, 0x01, 0x02, 0x00,
};

static struct usb_alternate_description mouse_data_alternate_descriptions[] = {
      { iInterface:"Simple Mouse Interface - Interrupt",
              interface_descriptor: (struct usb_interface_descriptor *)&mouse_data_alternate_descriptor,
              classes:sizeof (mouse_hid_descriptors) / sizeof (struct usb_generic_class_descriptor *),
              class_list: mouse_hid_descriptors,
	      endpoints:sizeof (mouse_default) / sizeof(struct usb_endpoint_descriptor *),
              endpoint_list: mouse_default,
              endpoint_indexes: mouse_indexes,
      },
};

/* Interface description(s)
 */
static struct usb_interface_description mouse_interfaces[] = {
      { alternates:sizeof (mouse_data_alternate_descriptions) / sizeof (struct usb_alternate_description),
              alternate_list:mouse_data_alternate_descriptions,},
};


/* Configuration description(s)
 */
static __u8 mouse_configuration_descriptor[sizeof(struct usb_configuration_descriptor)] = {
        0x09, USB_DT_CONFIG, 0x00, 0x00, // wLength
        sizeof (mouse_interfaces) / sizeof (struct usb_interface_description),
        0x01, 0x00, // bConfigurationValue, iConfiguration
        BMATTRIBUTE, BMAXPOWER,
};

struct usb_configuration_description mouse_description[] = {
      { configuration_descriptor: (struct usb_configuration_descriptor *)mouse_configuration_descriptor,
              iConfiguration:"USB Simple Serial Configuration",
	      bNumInterfaces:sizeof (mouse_interfaces) / sizeof (struct usb_interface_description),
              interface_list:mouse_interfaces,},
};

/* Device Description
 */
static struct usb_device_descriptor mouse_device_descriptor = {
	bLength: sizeof(struct usb_device_descriptor),
	bDescriptorType: USB_DT_DEVICE,
	bcdUSB: __constant_cpu_to_le16(USB_BCD_VERSION),
	bDeviceClass: 0x00,
	bDeviceSubClass: 0x00,
	bDeviceProtocol: 0x00,
	bMaxPacketSize0: 0x00,
	idVendor: __constant_cpu_to_le16(CONFIG_USBD_MOUSE_VENDORID),
	idProduct: __constant_cpu_to_le16(CONFIG_USBD_MOUSE_PRODUCTID),
	bcdDevice: __constant_cpu_to_le16(CONFIG_USBD_MOUSE_BCDDEVICE),
};

static struct usb_endpoint_request mouse_endpoint_requests[ENDPOINTS+1] = {
        { 1, 0, 0, USB_DIR_IN | USB_ENDPOINT_INTERRUPT, 16, 64, },
        { 0, },
};


struct usb_device_description mouse_device_description = {
        device_descriptor: &mouse_device_descriptor,
	iManufacturer: CONFIG_USBD_MOUSE_MANUFACTURER,
	iProduct: CONFIG_USBD_MOUSE_PRODUCT_NAME,
#if !defined(CONFIG_USBD_NO_SERIAL_NUMBER) && defined(CONFIG_USBD_SERIAL_NUMBER_STR)
	iSerialNumber: CONFIG_USBD_SERIAL_NUMBER_STR, 
#endif
        endpointsRequested: ENDPOINTS,
        requestedEndpoints: mouse_endpoint_requests,
};


/* MOUSE ***************************************************************************************** */

struct mouse_private {
        struct usb_function_instance *function;
        struct tq_struct notification_bh;
        int usb_driver_registered;              // non-zero if usb function registered
        unsigned char connected;                // non-zero if connected to host (configured)
        unsigned int writesize;                 // packetsize * 4
        struct urb *tx_urb;
        int wLength;
        int x;
        int y;
        int last_x;
        int last_y;
        int n;
};

struct mouse_private mouse_private;


/* Transmit Function *************************************************************************** */

int get_xy[8] = {
         0,  0,  1,  1, 
         0,  0, -1, -1, 
};

void mouse_send(struct usb_function_instance *function)
{
        struct mouse_private *mouse = &mouse_private;
        int new_x = 0;
        int new_y = 0;
        u8 random;

        memset(mouse->tx_urb->buffer, 0, 4);
        if (!mouse->n) {

                get_random_bytes(&random, 1);

                mouse->last_x = MAX(-4, MIN(4, mouse->last_x + get_xy[random & 0x7]));
                mouse->last_y = MAX(-4, MIN(4, mouse->last_y + get_xy[(random >> 3) & 0x7]));
                mouse->n = (random>>6) & 0x3;

                new_x = mouse->x + mouse->last_x;
                new_y = mouse->y + mouse->last_y;

                mouse->tx_urb->buffer[1] = mouse->last_x;
                mouse->x = new_x;
                mouse->tx_urb->buffer[2] = mouse->last_y;
                mouse->y = new_y;
                mouse->tx_urb->actual_length = 4;
#if 0
                printk(KERN_INFO"%s: x: %4d y: %4d rand: %02x x: %2d y: %2d new_x: %4d new_y: %4d  urb: %02x %02x %02x %02x\n", 
                                __FUNCTION__, 
                                mouse->x, mouse->y, random, x, y, new_x, new_y, 
                                mouse->tx_urb->buffer[0], mouse->tx_urb->buffer[1], 
                                mouse->tx_urb->buffer[2], mouse->tx_urb->buffer[3] );
#endif
        }
        else if ((mouse->n)&1) {
                mouse->n--;
        } 
        else {
                mouse->n--;
                mouse->tx_urb->buffer[1] = mouse->last_x;
                mouse->x = new_x;
                mouse->tx_urb->buffer[2] = mouse->last_y;
                mouse->y = new_y;
        }
        usbd_send_urb(mouse->tx_urb);
}

/* mouse_urb_sent - called to indicate URB transmit finished
 * @urb: pointer to struct urb
 * @rc: result
 */
int mouse_urb_sent (struct urb *urb, int rc)
{
        struct mouse_private *mouse = &mouse_private;
        struct usb_function_instance *function = mouse->function;

        RETURN_ZERO_IF(usbd_bus_status(function) == USBD_CLOSING);
        RETURN_ZERO_IF(usbd_bus_status(function) != USBD_OK);
        RETURN_ZERO_IF(usbd_device_state(function) != STATE_CONFIGURED);

        mouse_send(function);                                                   // re-send
        return 0;
}

/* USB Device Functions ************************************************************************ */

/* mouse_event_irq - process a device event
 *
 */
void mouse_event_irq (struct usb_function_instance *function, usb_device_event_t event, int data)
{
        struct mouse_private *mouse = &mouse_private;

	switch (event) {
	case DEVICE_CONFIGURED:
                mouse->connected = 1;
                if (!(mouse->tx_urb = usbd_alloc_urb (function, BULK_INT, 4, mouse_urb_sent))) 
                        printk(KERN_INFO"%s: alloc failed\n", __FUNCTION__);
                mouse_send(function);                                           // start sending
		break;

	case DEVICE_RESET:
	case DEVICE_DE_CONFIGURED:
                BREAK_IF(!mouse->connected);
                mouse->connected = 0;
                if (mouse->tx_urb) {
                        usbd_dealloc_urb (mouse->tx_urb);
                        mouse->tx_urb = NULL;
                }
		break;
        default: 
                break;
	}
}

/* copy_config
 * @urb: pointer to urb
 * @data: pointer to configuration data
 * @length: length of data
 *
 * Copy configuration data to urb transfer buffer if there is room for it.
 */
static int copy_report (struct urb *urb, void *data, int size, int max_buf)
{
	int available;
	int length;

	RETURN_EINVAL_IF (!urb);
	RETURN_EINVAL_IF (!data);
	RETURN_EINVAL_IF (!(length = size));
	RETURN_EINVAL_IF ((available = max_buf - urb->actual_length) <= 0);
	
	length = (length < available) ? length : available;
	memcpy (urb->buffer + urb->actual_length, data, length);
	urb->actual_length += length;
        return 0;
}

/* mouse_send_hid - send an EP0 urb containing HID report
 */
static int mouse_send_hid (void *data)
{
        struct mouse_private *mouse = &mouse_private;
	struct usb_function_instance *function = mouse->function;
        struct urb *urb = usbd_alloc_urb_ep0(function, mouse->wLength, NULL);
        RETURN_EINVAL_IF (copy_report(urb, MouseHIDReport, sizeof(MouseHIDReport), mouse->wLength));
        RETURN_ZERO_IF(!usbd_send_urb(urb));
        usbd_dealloc_urb(urb);
        return -EINVAL;
}

#ifdef CONFIG_USBD_MOUSE_BH
/* mouse_hid_bh - Bottom half handler to send a HID report
 */
static void mouse_hid_bh (void *data)
{
	struct usb_function_instance *function = mouse_private.function;
        mouse_send_hid(function);
        MOD_DEC_USE_COUNT;
}

/* mouse_schedule_bh - schedule a call for mouse_hid_bh
 */
static int mouse_schedule_bh (void)
{
        MOD_INC_USE_COUNT;
        if (!schedule_task (&mouse_private.notification_bh)) {
                MOD_DEC_USE_COUNT;
                return -EINVAL;
        }
        return 0;
}
#endif /* CONFIG_USBD_MOUSE_BH */



/* mouse_recv_setup_irq - called to indicate urb has been received
 */
int mouse_recv_setup_irq (struct usb_device_request *request)
{
	struct usb_function_instance *function = mouse_private.function;

        /* verify that this is a usb class request per cdc-mouse specification or a vendor request.
         * determine the request direction and process accordingly
         */
        switch (request->bmRequestType & (USB_REQ_DIRECTION_MASK | USB_REQ_TYPE_MASK)) {

        case USB_REQ_HOST2DEVICE:
        case USB_REQ_HOST2DEVICE | USB_REQ_TYPE_CLASS:
        case USB_REQ_HOST2DEVICE | USB_REQ_TYPE_VENDOR: 
                return 0;

        case USB_REQ_DEVICE2HOST :
        case USB_REQ_DEVICE2HOST | USB_REQ_TYPE_CLASS:
        case USB_REQ_DEVICE2HOST | USB_REQ_TYPE_VENDOR:

                switch (request->bRequest) {
                case USB_REQ_GET_DESCRIPTOR:
                        switch (le16_to_cpu(request->wValue)>>8) {
                        case HID_REPORT:
                                mouse_private.wLength = request->wLength;
#ifdef CONFIG_USBD_MOUSE_BH
                                return mouse_schedule_bh();
#else
                                return mouse_send_hid(function);
#endif
                        }
                default: break;
                }
                break;

        default:
                break;
        }
        return -EINVAL;
}


static int mouse_function_enable (struct usb_function_instance *function)
{
        struct mouse_private *mouse = &mouse_private;

	MOD_INC_USE_COUNT;
        mouse->function = function;
        mouse->n = 0;
        mouse->x = 0;
        mouse->y = 0;
        mouse->last_x = 0;
        mouse->last_y = 0;

        mouse->writesize = usbd_endpoint_wMaxPacketSize(function, BULK_INT, 0);

        return 0;
}

static void mouse_function_disable (struct usb_function_instance *function)
{               
        struct mouse_private *mouse = &mouse_private;
        mouse->function = NULL;
        mouse->writesize = 0;
        mouse->function = NULL;
	MOD_DEC_USE_COUNT;
}

static struct usb_function_operations function_ops = {
	event_irq: mouse_event_irq,
	recv_setup_irq: mouse_recv_setup_irq,
        function_enable: mouse_function_enable,
        function_disable: mouse_function_disable,
};

static struct usb_function_driver function_driver = {
	name:"mouse-random",
	fops:&function_ops,
	device_description:&mouse_device_description,
	bNumConfigurations:sizeof (mouse_description) / sizeof (struct usb_configuration_description),
	configuration_description:mouse_description,
	idVendor: __constant_cpu_to_le16(CONFIG_USBD_MOUSE_VENDORID),
	idProduct: __constant_cpu_to_le16(CONFIG_USBD_MOUSE_PRODUCTID),
	bcdDevice: __constant_cpu_to_le16(CONFIG_USBD_MOUSE_BCDDEVICE),
};


/* USB Module init/exit ************************************************************************ */
/*
 * mouse_modinit - module init
 *
 */
static int mouse_modinit (void)
{
	printk (KERN_INFO "%s: %s vendor_id: %04x product_id: %04x\n", __FUNCTION__, __usbd_module_info, vendor_id, product_id);

        if (vendor_id) 
                function_driver.idVendor = cpu_to_le16(vendor_id);
        if (product_id) 
                function_driver.idProduct = cpu_to_le16(product_id);

        mouse_hid.wItemLength = cpu_to_le16(0x34);      // XXX mips compiler bug.....

        // register as usb function driver
        THROW_IF (usbd_register_function (&function_driver), error);
        mouse_private.usb_driver_registered++;
#ifdef CONFIG_USBD_MOUSE_BH
        mouse_private.notification_bh.routine = mouse_hid_bh;
        mouse_private.notification_bh.data = NULL;
#endif
        CATCH(error) {
                if (mouse_private.usb_driver_registered) {
                        usbd_deregister_function (&function_driver);
                        mouse_private.usb_driver_registered = 0;
                }
                return -EINVAL;
        }
	return 0;
}

/* mouse_modexit - module cleanup
 */
static void mouse_modexit (void)
{
        if (mouse_private.usb_driver_registered) {
                usbd_deregister_function (&function_driver);
        }
}


module_init (mouse_modinit);
module_exit (mouse_modexit);
